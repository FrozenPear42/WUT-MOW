---
title: "Metody odkrywania wiedzy"
author: "Rafał Galczak, Wojciech Gruszka"
output: 
  pdf_document: default
  html_notebook: default
---

```{r}
library(ggplot2)
```

#Projekt

## Zagadnienie

___Temat:___ _Lokalna regresja (predykcja wartości funkcji docelowej dla przykładu za pomocą modelu jednorazowego użytku budowanego na podstawie jego „najbliższych sąsiadów”). Eksperymenty z kilkoma różnymialgorytmami do budowania modeli lokalnych. Porównanie z algorytmami regresji dostępnymi w R._

W ramach projektu należało napisać z użyciem pakietu R biblioteki/funkcji, która pozwoli na zastosowanie algorytmów regresji dostępnych w pakiecie R w trybie "lokalnym". sprowadza się to do znalezienia w zbiorze danych (który musi być do tego odpowiednio przygotowany) zbioru trenującego dla danego przykładu z użyciem algorytmu k-najbliższych sąsiadów. Następnie dla takiego zbioru należy zastosować wybrany algorytm regresji z pakietu R. Jako algorytmy budowania modeli należy zastosować dostępne w pakiecie R algorytmy regresjii. Wykorzystane algorytmy zostały opisane w dalszej części.

W ramach projektu miały zostać przeprowadzone testy sprawdzające działanie usyskanego kodu dla kilku algorytmów oraz zbiorów danych.

## Czemu warto zająć się takim zagadnieniem
Samo zadanie jest dość ciekawe ze względu na to, że istnieją sensowne algorytmy pozwalające na realizację regresji lokalnej takie jak _LOES_ czy _LOWESS_. Jednym z powodów może być tutaj chęć przetestowania sprawności algorytmów regresji w trybie lokalnym i weryfikacji poprawności ich działania. Zastosowanie algorytmów budowanaia modeli regresji w trybie lokalnym pozwala na znaczne zmniejszenie czasu i zasobów potrzebnych do wykonania predykcji, co wynika ze znacznego ograniczenia liczebności danych trenujących do tylko tych z bezpośredniego obszaru (k-najbliższych sąsiadów).


## Zbiory danych
Do projektu musieliśmy wybrać zbiory danych testowych które powinny spełniać wymagania:
 - liczba atrybutów powinna być odpowiednio duża (>5 atrybutów)
 - zmienna objaśniana powinna być ciągła lub zachowywać sens w przypadku interpolacji (np. ocena filmu w skali dyskretnej 1-10 zachowuje sens dla wartości 9.81)
 - zbiór danych powinien zawierać odpowiednio dużo przykładów

Po długich poszukiwaniach sensownych i odpowiednio ciekawych danych do analizy na dostępnych portalach udostępniających zbiory danych (Kaggle, Data.World) zdecydowaliśmy się na następujące propozycje:

### Zbiór dancyh wypożyceń rowerów w systemie wypożyczalni
Dane pochodzą ze strony: [https://data.world/data-society/capital-bikeshare-2011-2012]().

Zbiór zawiera 17379 przykładów dotyczących wypożyczeń rowerów w systemie wypożyczalni w Waszyngtonie. Dostępne są atrybuty związane z czasem wypożyczenia (dzień tygodnia, godzina), pogodą (temperatura, wiilgotność, prędkość wiatru) oraz liczby wypożyczonych rowerów (użytkownicy zarejsetrowani, użytkownicy niezarejestrowani, użytkownicy łącznie).W szczególności regresję można badać w zakresie łącznej liczby wypożyczeń. Zbiór wydaje się dość ciekawy do zbadania oraz jest wystarczająco duży.

```{r}
bikes <- read.csv("https://query.data.world/s/jcpgkqdal2ztirvoahx5dmopkpzr7q", header=TRUE, stringsAsFactors=FALSE)
bikes$Casual.Users <- NULL
bikes$Registered.Users <- NULL

```


### Zbiór danych używanych samochodów
Dane pochodzą ze strony: [https://www.kaggle.com/c/usedcarvaluation]()

Zbiór zawiera 70000 obserwacji (przykładów) dotyczących cen sprzedaży samochodów osobowych o określonej marce, wieku, pojemności silnika, mocy, przejechanej odlegółości oraz liczby poprzednich właścicieli. Wszystkie atrybuty poza marką są atrybutami ciągłymi (bądź dającymi się uciąglić). Atrybutem przywidywanym dla tego zbioru jest wartość samochodu.

```{r}
cars <- read.csv("cars.csv", header=TRUE, stringsAsFactors=FALSE)
cars$year <- NULL
```


### Zbiór danych nieruchomości
Dane pochodzą ze strony: [https://www.kaggle.com/quantbruce/real-estate-price-prediction]()

Zbiór zawiera 414 obserwacji dotyczących sprzedaży nieruchomości (domów i mieszkań) opisanych z użyciem daty transakcji, wieku nieruchomości, odległości od przystanku, liczby skelpów w okolicy, położenia geograficznego oraz ceny za jednostkę powierzchni. W przypadku tych danych będziemy przewidywać cenę za jednostkę powierzchni.

```{r}
real_estate <- read.csv("real_estate.csv", header=TRUE, stringsAsFactors=FALSE)
real_estate$No <- NULL
```

=======
### Normalizacja i denormalizacja danych
W celu poprawnego zastosowania metody kNN (k najbliższych sąsiadów) do ogreślenia zbioru terningowego dane muszą być uprzednio znormalizowane. Jest to wymagane, ponieważ algorytm kNN bazuje na funkcji odległości. Brak normalizacji sprawiłby, że jeden z atrybutów byłby wyróżniony ze względu na większy zakres wartosci. Stosuje się trzy rozdzaje normalizacji:
 - Liniowe przeskalowanie wartości do przedizału $[0-1]$ dla atrybutów ograniczonych (o ustalonych wartościach minimalnej i maksymalnej)
 - Przeskalowanie z użyciem rozkładu normalnego o średniej $Ex = 0$ i wariancji $\sigma^{2} = 1$. - dla wartości nieograniczonych
 - Przydzielenie wartości $[0-1]$ rozłożonych równomiernie dla atrybutów dyskretnych
 
W pakiecie taka normalizacja może zostać wykonana automatycznie przez zastosowanie funckcji ``.

```{r}
source('localRegression.R')
rs_model <- createLocalRegressionModel(real_estate, list("minmax","minmax","minmax","minmax","minmax","minmax","omit"))
wrap(rs_model, real_estate[1,], 1, "cover_tree", lm, house.price.of.unit.area ~ house.age)[[1]]
wrap(rs_model, real_estate[1,], 10, "cover_tree", lm, house.price.of.unit.area ~ house.age)[[1]]
wrap(rs_model, real_estate[1,], 100, "cover_tree", lm, house.price.of.unit.area ~ house.age)[[1]]
wrap(rs_model, real_estate[1,], 200, "cover_tree", lm, house.price.of.unit.area ~ house.age)[[1]]
wrap(rs_model, real_estate[1,], 414, "cover_tree", lm, house.price.of.unit.area ~ house.age)[[1]]
```
```{r}
source('localRegression.R')
rs_model <- createLocalRegressionModel(real_estate, list("minmax","minmax","minmax","minmax","minmax","minmax","omit"))
wrap(rs_model, real_estate[1,], 1, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
wrap(rs_model, real_estate[1,], 10, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
wrap(rs_model, real_estate[1,], 100, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
wrap(rs_model, real_estate[1,], 200, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
wrap(rs_model, real_estate[1,], 414, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
```
```{r}
source('localRegression.R')
rs_model <- createLocalRegressionModel(real_estate, list("zscore","zscore","zscore","zscore","zscore","zscore","omit"))
wrap(rs_model, real_estate[1,], 1, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
wrap(rs_model, real_estate[1,], 10, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
wrap(rs_model, real_estate[1,], 100, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
wrap(rs_model, real_estate[1,], 200, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
wrap(rs_model, real_estate[1,], 414, "cover_tree", rpart, house.price.of.unit.area ~ house.age, method="anova")[[1]]
```


## Implementacja

!!!TUTAJ JAKIŚ ŁADNY WSTĘP!!!

Funkcja `wrap` opakowuje funkcję do budowania modelu liniowego i dokonuje predykcji z
użyciem modelu lokalnego wyznaczonego przez funkcję `get.knn`.
Jako argumenty funkcja `wrap` przyjmuje obiekt danych, parametry `n` i `dist_method`
przekazowane do funkcji `get.knn` oraz funkcję do opakowania i ew. dodatkowe argumenty dla niej.

Dodatkowo zapewniamy 3 funkcje ułatwiające korzystanie z funkcji `wrap`.
`default.wrap` zapewnia domyślne wartości dla paramtru `n` i `dist_method`.
`n` jest ustawione jako 100 i jako `dist_method` przekazywana jest wartość `euclidean`.
Funkcja ta może zostać użyta jako punkt wyjścia do dostosowywania metaparemtrów algorytmu.

Funkcje `localLinear.wrap` używa funkcji `default.wrap` do obudowania wbudowanej
funkcji `lm`. Funkcja ta jako dodatkowy argument przyjmuje też formułę, która
zostanie przekazana do funkcji `lm`.

Tak samo jak `localLiner.wrap` funkcja `regressionTree.wrap` zapewnia proste opakowanie
dla funkcji `rpart` z biblioteki `rpart`. 

Funkcja `get.knn` przyjmuje zbiór treningowy, wektor `x` i znajduje `n` najbliższych
sąsiadów w zbiorze treningowym dla wektora `x` używając wbudowanej funkcji `dist` i
przekazując jej `dist_method`. 

### Model regresji liniowej

!!! DAĆ WYNIKI !!!

### Model drzew regresji

!!! DAĆ WYNIKI !!!

## Użycie pakietu

## Metody regresji lokalnej z pakietu R
### LOESS
### LOWESS

## Wyniki i porównanie z metodami regresji lokalnej dostępnymi w pakiecie R
